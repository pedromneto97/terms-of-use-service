use actix_web::{HttpResponse, http::StatusCode};
use serde::Serialize;
use std::fmt;

/// Response structure following RFC 9457 - Problem Details for HTTP APIs
///
/// This struct represents the standard problem details object as defined in
/// https://datatracker.ietf.org/doc/html/rfc9457
///
/// The media type for this format is "application/problem+json"
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ProblemDetails {
    /// A URI reference that identifies the problem type.
    /// When this member is not present, its value is assumed to be "about:blank".
    #[serde(rename = "type")]
    pub problem_type: String,

    /// A short, human-readable summary of the problem type.
    /// It SHOULD NOT change from occurrence to occurrence of the problem,
    /// except for localization.
    pub title: String,

    /// The HTTP status code generated by the origin server for this occurrence
    /// of the problem.
    pub status: u16,

    /// A human-readable explanation specific to this occurrence of the problem.
    /// The "detail" string, if present, ought to focus on helping the client
    /// correct the problem, rather than giving debugging information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,

    /// A URI reference that identifies the specific occurrence of the problem.
    /// It may or may not yield further information if dereferenced.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,
}

impl ProblemDetails {
    /// Creates a new ProblemDetails with the required fields
    pub fn new(
        problem_type: impl Into<String>,
        title: impl Into<String>,
        status: StatusCode,
    ) -> Self {
        Self {
            problem_type: problem_type.into(),
            title: title.into(),
            status: status.as_u16(),
            detail: None,
            instance: None,
        }
    }

    /// Creates a ProblemDetails with the "about:blank" type, which indicates
    /// the problem has no additional semantics beyond that of the HTTP status code.
    pub fn blank(status: StatusCode) -> Self {
        let title = status
            .canonical_reason()
            .unwrap_or("Unknown Error")
            .to_string();

        Self {
            problem_type: "about:blank".to_string(),
            title,
            status: status.as_u16(),
            detail: None,
            instance: None,
        }
    }

    /// Sets the detail field
    pub fn with_detail(mut self, detail: impl Into<String>) -> Self {
        self.detail = Some(detail.into());
        self
    }

    /// Sets the instance field
    pub fn with_instance(mut self, instance: impl Into<String>) -> Self {
        self.instance = Some(instance.into());
        self
    }

    /// Converts the ProblemDetails into an HttpResponse with the correct
    /// Content-Type header (application/problem+json)
    pub fn into_response(self) -> HttpResponse {
        let status = StatusCode::from_u16(self.status).unwrap_or(StatusCode::INTERNAL_SERVER_ERROR);

        HttpResponse::build(status)
            .content_type("application/problem+json")
            .json(self)
    }
}

/// Convenience functions for common HTTP error responses
impl ProblemDetails {
    /// Creates a 400 Bad Request problem
    pub fn bad_request() -> Self {
        Self::blank(StatusCode::BAD_REQUEST)
    }

    /// Creates a 401 Unauthorized problem
    pub fn unauthorized() -> Self {
        Self::blank(StatusCode::UNAUTHORIZED)
    }

    /// Creates a 403 Forbidden problem
    pub fn forbidden() -> Self {
        Self::blank(StatusCode::FORBIDDEN)
    }

    /// Creates a 404 Not Found problem
    pub fn not_found() -> Self {
        Self::blank(StatusCode::NOT_FOUND)
    }

    /// Creates a 409 Conflict problem
    pub fn conflict() -> Self {
        Self::blank(StatusCode::CONFLICT)
    }

    /// Creates a 422 Unprocessable Entity problem
    pub fn unprocessable_entity() -> Self {
        Self::blank(StatusCode::UNPROCESSABLE_ENTITY)
    }

    /// Creates a 500 Internal Server Error problem
    pub fn internal_server_error() -> Self {
        Self::blank(StatusCode::INTERNAL_SERVER_ERROR)
    }

    /// Creates a 503 Service Unavailable problem
    pub fn service_unavailable() -> Self {
        Self::blank(StatusCode::SERVICE_UNAVAILABLE)
    }
}

impl fmt::Display for ProblemDetails {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "ProblemDetails(type: {}, title: {}, status: {}, detail: {}, instance: {})",
            self.problem_type,
            self.title,
            self.status,
            self.detail.as_deref().unwrap_or("-"),
            self.instance.as_deref().unwrap_or("-")
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_problem_details_serialization() {
        let problem = ProblemDetails::new(
            "https://example.com/probs/out-of-credit",
            "You do not have enough credit.",
            StatusCode::FORBIDDEN,
        )
        .with_detail("Your current balance is 30, but that costs 50.")
        .with_instance("/account/12345/msgs/abc");

        let json = serde_json::to_string(&problem).unwrap();

        assert!(json.contains("\"type\":\"https://example.com/probs/out-of-credit\""));
        assert!(json.contains("\"title\":\"You do not have enough credit.\""));
        assert!(json.contains("\"status\":403"));
        assert!(json.contains("\"detail\":\"Your current balance is 30, but that costs 50.\""));
        assert!(json.contains("\"instance\":\"/account/12345/msgs/abc\""));
    }

    #[test]
    fn test_blank_problem_details() {
        let problem = ProblemDetails::blank(StatusCode::NOT_FOUND);

        assert_eq!(problem.problem_type, "about:blank");
        assert_eq!(problem.title, "Not Found");
        assert_eq!(problem.status, 404);
        assert!(problem.detail.is_none());
        assert!(problem.instance.is_none());
    }

    #[test]
    fn test_optional_fields_not_serialized_when_none() {
        let problem = ProblemDetails::not_found();
        let json = serde_json::to_string(&problem).unwrap();

        assert!(!json.contains("detail"));
        assert!(!json.contains("instance"));
    }
}
