use actix_web::http::StatusCode;
use serde::Serialize;
use std::fmt;

/// Response structure following RFC 9457 - Problem Details for HTTP APIs
///
/// This struct represents the standard problem details object as defined in
/// https://datatracker.ietf.org/doc/html/rfc9457
///
/// The media type for this format is "application/problem+json"
#[derive(Debug, Clone, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct ProblemDetails {
    /// A URI reference that identifies the problem type.
    /// When this member is not present, its value is assumed to be "about:blank".
    #[serde(rename = "type")]
    pub problem_type: String,

    /// A short, human-readable summary of the problem type.
    /// It SHOULD NOT change from occurrence to occurrence of the problem,
    /// except for localization.
    pub title: String,

    /// The HTTP status code generated by the origin server for this occurrence
    /// of the problem.
    pub status: u16,

    /// A human-readable explanation specific to this occurrence of the problem.
    /// The "detail" string, if present, ought to focus on helping the client
    /// correct the problem, rather than giving debugging information.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub detail: Option<String>,

    /// A URI reference that identifies the specific occurrence of the problem.
    /// It may or may not yield further information if dereferenced.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instance: Option<String>,
}

impl ProblemDetails {
    /// Creates a ProblemDetails with the "about:blank" type, which indicates
    /// the problem has no additional semantics beyond that of the HTTP status code.
    pub fn blank(status: StatusCode) -> Self {
        let title = status
            .canonical_reason()
            .unwrap_or("Unknown Error")
            .to_string();

        Self {
            problem_type: "about:blank".to_string(),
            title,
            status: status.as_u16(),
            detail: None,
            instance: None,
        }
    }

    /// Sets the detail field
    pub fn with_detail(mut self, detail: impl Into<String>) -> Self {
        self.detail = Some(detail.into());
        self
    }
}

/// Convenience functions for common HTTP error responses
impl ProblemDetails {
    /// Creates a 400 Bad Request problem
    pub fn bad_request() -> Self {
        Self::blank(StatusCode::BAD_REQUEST)
    }

    /// Creates a 404 Not Found problem
    pub fn not_found() -> Self {
        Self::blank(StatusCode::NOT_FOUND)
    }

    /// Creates a 500 Internal Server Error problem
    pub fn internal_server_error() -> Self {
        Self::blank(StatusCode::INTERNAL_SERVER_ERROR)
    }
}

impl fmt::Display for ProblemDetails {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "ProblemDetails(type: {}, title: {}, status: {}, detail: {}, instance: {})",
            self.problem_type,
            self.title,
            self.status,
            self.detail.as_deref().unwrap_or("-"),
            self.instance.as_deref().unwrap_or("-")
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_blank_problem_details() {
        let problem = ProblemDetails::blank(StatusCode::INTERNAL_SERVER_ERROR);

        assert_eq!(problem.problem_type, "about:blank");
        assert_eq!(problem.title, "Internal Server Error");
        assert_eq!(problem.status, 500);
        assert!(problem.detail.is_none());
        assert!(problem.instance.is_none());
    }

    #[test]
    fn test_optional_fields_not_serialized_when_none() {
        let problem = ProblemDetails::not_found();
        let json = serde_json::to_string(&problem).unwrap();

        assert!(!json.contains("detail"));
        assert!(!json.contains("instance"));
    }
}
